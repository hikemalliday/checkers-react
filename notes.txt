line 379

-Need to re render after refreshing boardState-
-DELETE seems to be bugging out the refresh somehow?
TODO:
   -Add parameter typing to 'setBoardState'
-JUMPS:
  -BLACK:
    -black down left
  -RED UP RIGHT:
    -Somehow the jump + the movement rendered at the same time
    -Test all jumps, seems like the jump rendered before the previous move
  DOWN RIGHT jumps not erasing the jumped piece, and kings not showing up when reaching board end, and kings not upgrading on jumps?
  -CHECK DOWN RIGHT LOGIC

-Need to fetch GAMEIDS on page Replay

-GAMEID 12:
  -black: y3x7 y4x6
  -red: y6x6 y5x7
  -black: y3x1 y4x2

-Need to re-render the replayBoard on.... boardState change


-NEED TO ADD THESE PROPERTIES TO REPLAY.TSX:
    -redScore
    -blackScore
    -activePlayer
    -turnId

-REPLAY STATE MANAGEMENT:
    -App.tsx:
        -fetchReplay(game_id: number)
    -ReplayBoard.tsx:
        -const replayRef = useRef([]);
        -const getReplay = async () =>
        {
          const results = await fetchReplay(game_id);
          replayRef.current = results;
        }
    
-REPLAYS page:
    -SCORE                         ACTIVE PLAYER                             SELECT REPLAY
    -TURN ID



-We must create another propertie 'WINNER' if we reach a winner state

-REPLAYS PULLDONW:
  -Upon component render, fetch is called
  -Populate pulldown with fetched
  -watch vid for a nice pulldown

-PROBLEM:
  -Its marking the 
  -On a double jump, the turn
-Call push inside useeffect in board.tsx
-The problem is, we are trying to reliably push 'useState' data
    -If we saved and pushed useRef() data, perhaps this could be 
    -Create useRef() data for all, in the parent component
    -Need to add activeplayer, turnId, redscore, blackscore, moevstart, and moveend REF's in Board.tsx
    -activePlayer **

-Change pieces to kings at ends
    -If we upgrade to king on final jump, and there is a backwards jump, it doesnt scan for it
        -It likely only did the regular jump check upon landing.
            -How do we fix this?
                -Add a full scan for regular jumps?
                    -Add a king check inside regular jump. If true, call isKingJumpValid(), then return;
    -Logic to upgrade a piece after jumping a king
    -When a regular piece hits opposite end, convert to king
        -if Y == 1 && piece == red, upgrade
        -if Y == 8 && piece == black, upgrade
        -Upgrade + deal with multi jumps
-SO BEGINS THE FUN:
    -Dealing with turns / replays

-refactor name: 'keyMoveSTart' to 'moveStartKey', or refactor other stuff vice versa
-Make King images
-King jump logic:
    -Kings can jump either way, so the only stipulations:
        -Jumped piece must be !== activePlayer
        -Must be Math.abs(1) x and y
-BUGS:
    -Jumps arent clearing 'invalidMove'
    
-Database:
    -"""CREATE TABLE game IF NOT EXISTS (
        game_id INTEGER AUTOINCREMENT PRIMARY KEY,
        date TIMESTAMP,
        winner INTEGER (0=Draw, 1=Red, 2=Blue)
    )
    -"""CREATE TABLE turns IF NOT EXISTS (
        turn_id INTEGER PRIMARY KEY,
        game_id INTEGER,
        red_score INTEGER,
        blue_score INTEGER,
        player INTEGER,
        move_from_x INTEGER,
        move_from_y INTEGER,
        move_to_x INTEGER,
        move_to_y INTEGER
    )
        
-REFACTOR:
    -const [gameState, setGameState] = useState({
  activePlayer: "Black",
  turnId: 1,
  invalidMove: false,
  chooseDoubleJump: false,
  redScore: 0,
  blackScore: 0,
  gameTurns: [],
  moveStart: ["", ""],
  moveEnd: ["", ""],
});

export const NewGame = () => {
  const [gameState, setGameState] = useState({
    activePlayer: "Black",
    turnId: 1,
    invalidMove: false,
    chooseDoubleJump: false,
    redScore: 0,
    blackScore: 0,
    gameTurns: [],
    moveStart: ["", ""],
    moveEnd: ["", ""],
  });

  const updateGameState = (newState) => {
    setGameState((prevState) => ({
      ...prevState,
      ...newState,
    }));
  };

  const pushGameTurn = () => {
    // ... your existing logic to update gameTurns
  };

  // Define other helper functions for game logic here

  const handleClick = (e: React.MouseEvent) => {
    // ... your existing logic to handle click events
  };

  const handleOnDragOver = (e: React.DragEvent) => {
    // ... your existing logic to handle drag-over events
  };

  const handleOnDrop = (e: React.DragEvent) => {
    // ... your existing logic to handle drop events
  };

  return (
    <>
      {/* Render your game board and components based on game state */}
    </>
  );
};

export default NewGame;


Optimizing Rerenders: For a game, it's important to optimize re-renders. If you find that your component is re-rendering more frequently than necessary, you can use techniques like memoization or shouldComponentUpdate in class components to control when re-renders occur.
Use useCallback: For functions that are used as dependencies in useEffect, you can wrap them with useCallback to memoize them. This is especially important for functions that are passed as props to child components to prevent re-renders in child components.


-ARE TWO TABLES NEEDED?:
    -This way stores the winner, TIMESTAMP
    -When game is uploaded prematurely, draw is stored, timestamp is taken

    -REPLAY:
        -With replays, we dont have to check for logic
            -If game_type='replay', ignore all movement logic.
            -Infact, ignore all logic except for clearing a space due to jumping.
        -With this stored data, first we store the 'piece_type' of 'move_from'. Then, we move that piece type to 'move_to'. If its a jump, remove the piece inbetween
        